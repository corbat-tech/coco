/**
 * Quality Report Exporter
 *
 * Serialises a `QualityEvaluation` into JSON, Markdown, or HTML and optionally
 * persists it under `.coco/reports/` inside the project directory.
 *
 * Usage:
 *   const exporter = new QualityReportExporter();
 *   const md = exporter.toMarkdown(evaluation);
 *   const path = await exporter.saveReport(evaluation, "/my/project", "markdown");
 */

import { writeFile, mkdir } from "node:fs/promises";
import { join, resolve } from "node:path";
import type { QualityEvaluation, QualityIssue, QualitySuggestion } from "./types.js";
import { DIMENSION_LABELS, DIMENSION_ORDER } from "./dimension-constants.js";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Types
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export type ReportFormat = "json" | "markdown" | "html";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// QualityReportExporter
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export class QualityReportExporter {
  // â”€â”€ JSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Serialize the evaluation to pretty-printed JSON.
   * Dates are converted to ISO 8601 strings automatically.
   */
  toJson(evaluation: QualityEvaluation): string {
    return JSON.stringify(evaluation, null, 2);
  }

  // â”€â”€ Markdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Render the evaluation as a Markdown document suitable for PR comments,
   * GitHub wikis, or README badges.
   */
  toMarkdown(evaluation: QualityEvaluation): string {
    const overall = Math.round(evaluation.scores.overall);
    const status = evaluation.meetsMinimum ? "âœ… PASS" : "âŒ FAIL";
    const evaluatedAt = evaluation.scores.evaluatedAt.toISOString().slice(0, 10);

    const lines: string[] = [
      `# Quality Report`,
      ``,
      `**Overall Score:** ${overall}/100 ${status}  `,
      `**Evaluated:** ${evaluatedAt}  `,
      `**Duration:** ${evaluation.scores.evaluationDurationMs}ms`,
      ``,
      `## Dimensions`,
      ``,
      `| Dimension | Score | Status |`,
      `|-----------|------:|--------|`,
    ];

    for (const key of DIMENSION_ORDER) {
      const score = Math.round(evaluation.scores.dimensions[key] ?? 0);
      const icon = score >= 90 ? "âœ…" : score >= 75 ? "âš ï¸" : "âŒ";
      lines.push(`| ${DIMENSION_LABELS[key]} | ${score} | ${icon} |`);
    }

    lines.push(`| **Overall** | **${overall}** | ${status} |`);

    if (evaluation.issues.length > 0) {
      lines.push(``, `## Issues (${evaluation.issues.length})`, ``);
      for (const issue of evaluation.issues) {
        lines.push(this.markdownIssue(issue));
      }
    }

    if (evaluation.suggestions.length > 0) {
      lines.push(``, `## Suggestions`, ``);
      for (const s of evaluation.suggestions.slice(0, 5)) {
        lines.push(this.markdownSuggestion(s));
      }
    }

    lines.push(``, `---`, `*Generated by Corbat-Coco*`);

    return lines.join("\n");
  }

  // â”€â”€ HTML â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Render the evaluation as a self-contained HTML page.
   */
  toHtml(evaluation: QualityEvaluation): string {
    const overall = Math.round(evaluation.scores.overall);
    const status = evaluation.meetsMinimum ? "PASS" : "FAIL";
    const statusColor = evaluation.meetsMinimum ? "#22c55e" : "#ef4444";
    const evaluatedAt = evaluation.scores.evaluatedAt.toISOString().slice(0, 19).replace("T", " ");

    const dimensionRows = DIMENSION_ORDER.map((key) => {
      const score = Math.round(evaluation.scores.dimensions[key] ?? 0);
      const color = score >= 90 ? "#22c55e" : score >= 75 ? "#f59e0b" : "#ef4444";
      const barWidth = score;
      return `
        <tr>
          <td>${this.htmlEscape(DIMENSION_LABELS[key])}</td>
          <td style="text-align:right"><strong>${score}</strong></td>
          <td><div style="background:#e5e7eb;border-radius:4px;width:200px">
            <div style="background:${color};width:${barWidth}%;height:16px;border-radius:4px"></div>
          </div></td>
        </tr>`;
    }).join("");

    const issuesHtml =
      evaluation.issues.length === 0
        ? "<p>No issues found.</p>"
        : `<ul>${evaluation.issues
            .map(
              (i) =>
                `<li><strong>[${this.htmlEscape(i.dimension)}]</strong> ${this.htmlEscape(i.message)}</li>`,
            )
            .join("")}</ul>`;

    const suggestionsHtml =
      evaluation.suggestions.length === 0
        ? "<p>No suggestions.</p>"
        : `<ul>${evaluation.suggestions
            .slice(0, 5)
            .map(
              (s) =>
                `<li><strong>[${this.htmlEscape(s.dimension)}]</strong> ${this.htmlEscape(s.description)} <em>(+${s.estimatedImpact} pts)</em></li>`,
            )
            .join("")}</ul>`;

    return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quality Report</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; color: #111827; }
  h1 { border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
  table { border-collapse: collapse; width: 100%; }
  th, td { text-align: left; padding: 0.4rem 0.75rem; border-bottom: 1px solid #e5e7eb; }
  th { background: #f9fafb; font-weight: 600; }
  .badge { display: inline-block; padding: 0.25rem 0.75rem; border-radius: 999px; color: #fff; font-weight: 700; font-size: 1.1rem; background: ${statusColor}; }
  footer { margin-top: 2rem; color: #6b7280; font-size: 0.875rem; }
</style>
</head>
<body>
<h1>Quality Report</h1>
<p><span class="badge">${status}</span> &nbsp; Overall score: <strong>${overall}/100</strong></p>
<p style="color:#6b7280">Evaluated: ${evaluatedAt} &middot; Duration: ${evaluation.scores.evaluationDurationMs}ms</p>

<h2>Dimensions</h2>
<table>
  <thead><tr><th>Dimension</th><th>Score</th><th>Bar</th></tr></thead>
  <tbody>${dimensionRows}
  </tbody>
</table>

<h2>Issues</h2>
${issuesHtml}

<h2>Suggestions</h2>
${suggestionsHtml}

<footer>Generated by <a href="https://github.com/corbat-tech/coco">Corbat-Coco</a></footer>
</body>
</html>`;
  }

  // â”€â”€ Persist â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Serialize and write the report to `.coco/reports/` in the project root.
   *
   * @returns Absolute path to the written file.
   */
  async saveReport(
    evaluation: QualityEvaluation,
    projectPath: string,
    format: ReportFormat = "markdown",
  ): Promise<string> {
    const dir = join(resolve(projectPath), ".coco", "reports");
    await mkdir(dir, { recursive: true });

    const ext = format === "json" ? "json" : format === "html" ? "html" : "md";
    const timestamp = evaluation.scores.evaluatedAt
      .toISOString()
      .replace(/[:.]/g, "-")
      .slice(0, 19);
    const filename = `quality-${timestamp}.${ext}`;
    const filePath = join(dir, filename);

    const content =
      format === "json"
        ? this.toJson(evaluation)
        : format === "html"
          ? this.toHtml(evaluation)
          : this.toMarkdown(evaluation);

    await writeFile(filePath, content, "utf-8");
    return filePath;
  }

  // â”€â”€ Private helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private htmlEscape(text: string): string {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  private markdownIssue(issue: QualityIssue): string {
    const severity =
      issue.severity === "critical" ? "ðŸ”´" : issue.severity === "major" ? "ðŸŸ¡" : "ðŸ”µ";
    const location =
      issue.file !== undefined
        ? ` \`${issue.file}${issue.line !== undefined ? `:${issue.line}` : ""}\``
        : "";
    const suggestion = issue.suggestion ? `  \n  â†’ _${issue.suggestion}_` : "";
    return `- ${severity} **[${issue.dimension}]** ${issue.message}${location}${suggestion}`;
  }

  private markdownSuggestion(s: QualitySuggestion): string {
    const priority = s.priority === "high" ? "ðŸ”´" : s.priority === "medium" ? "ðŸŸ¡" : "ðŸ”µ";
    return `- ${priority} **[${s.dimension}]** ${s.description} _(+${s.estimatedImpact} pts)_`;
  }
}

/** Shared singleton exporter */
export const qualityReportExporter = new QualityReportExporter();
