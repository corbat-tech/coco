/**
 * Markdown generation for architecture documents
 */

import type { ArchitectureDoc } from "./types.js";

/**
 * Generate architecture markdown document
 */
export function generateArchitectureMarkdown(doc: ArchitectureDoc): string {
  const sections: string[] = [];

  // Header
  sections.push("# Architecture Document");
  sections.push("");
  sections.push(`> Generated: ${doc.generatedAt.toISOString()} | Version: ${doc.version}`);
  sections.push("");

  // Overview
  sections.push("## Overview");
  sections.push("");
  sections.push(`**Pattern:** ${doc.overview.pattern}`);
  sections.push("");
  sections.push(doc.overview.description);
  sections.push("");

  // Principles
  if (doc.overview.principles.length > 0) {
    sections.push("### Design Principles");
    sections.push("");
    for (const principle of doc.overview.principles) {
      sections.push(`- ${principle}`);
    }
    sections.push("");
  }

  // Quality Attributes
  if (doc.overview.qualityAttributes.length > 0) {
    sections.push("### Quality Attributes");
    sections.push("");
    sections.push("| Attribute | Priority | Description |");
    sections.push("|-----------|----------|-------------|");
    for (const qa of doc.overview.qualityAttributes) {
      sections.push(`| ${qa.name} | ${qa.priority} | ${qa.description} |`);
    }
    sections.push("");
  }

  // Components
  sections.push("## Components");
  sections.push("");
  for (const component of doc.components) {
    sections.push(`### ${component.name}`);
    sections.push("");
    sections.push(`**Type:** ${component.type}`);
    if (component.layer) sections.push(`**Layer:** ${component.layer}`);
    if (component.technology) sections.push(`**Technology:** ${component.technology}`);
    sections.push("");
    sections.push(component.description);
    sections.push("");
    if (component.responsibilities.length > 0) {
      sections.push("**Responsibilities:**");
      for (const resp of component.responsibilities) {
        sections.push(`- ${resp}`);
      }
      sections.push("");
    }
  }

  // Data Models
  if (doc.dataModels.length > 0) {
    sections.push("## Data Models");
    sections.push("");
    for (const model of doc.dataModels) {
      sections.push(`### ${model.name}`);
      sections.push("");
      sections.push(model.description);
      sections.push("");
      sections.push("| Field | Type | Required |");
      sections.push("|-------|------|----------|");
      for (const field of model.fields) {
        sections.push(`| ${field.name} | ${field.type} | ${field.required ? "Yes" : "No"} |`);
      }
      sections.push("");
    }
  }

  // Integrations
  if (doc.integrations.length > 0) {
    sections.push("## Integrations");
    sections.push("");
    for (const integration of doc.integrations) {
      sections.push(`### ${integration.name}`);
      sections.push("");
      sections.push(`**Type:** ${integration.type}`);
      sections.push(integration.description);
      sections.push("");
    }
  }

  // Diagrams
  if (doc.diagrams.length > 0) {
    sections.push("## Diagrams");
    sections.push("");
    for (const diagram of doc.diagrams) {
      sections.push(`### ${diagram.title}`);
      sections.push("");
      sections.push(diagram.description);
      sections.push("");
      sections.push("```mermaid");
      sections.push(diagram.mermaid);
      sections.push("```");
      sections.push("");
    }
  }

  sections.push("---");
  sections.push("");
  sections.push("*Generated by Corbat-Coco*");

  return sections.join("\n");
}
